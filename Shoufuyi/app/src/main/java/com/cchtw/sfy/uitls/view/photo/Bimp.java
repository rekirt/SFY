package com.cchtw.sfy.uitls.view.photo;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import java.io.File;import java.io.IOException;import java.util.ArrayList;/**   *  * Description: * Created by Fu.H.L on  * Date:2015-9-20-上午12:41:12 * Copyright © 2015年 Fu.H.L All rights reserved. */public class Bimp {	public static int max = 0;    //选择的图片的临时列表    public static ArrayList<ImageItem> tempSelectBitmap = new ArrayList<ImageItem>();    public static Bitmap revitionImageSize(String path) throws IOException {//        BufferedInputStream in = new BufferedInputStream(new FileInputStream(//                new File(path)));        Bitmap bitmap = null;        BitmapFactory.Options options = new BitmapFactory.Options();        options.inJustDecodeBounds = true;        BitmapFactory.decodeFile(path, options);        int height = options.outHeight * 500 / options.outWidth;        bitmap = getBitmapFromFile(new File(path),500,height);//        BitmapFactory.decodeStream(in, null, options);//        in.close();//        int i = 0;////        while (true) {//            if ((options.outWidth >> i <= 1000) && (options.outHeight >> i <= 1000)) {//                in = new BufferedInputStream(//                        new FileInputStream(new File(path)));//                options.inSampleSize = (int) Math.pow(3.0D, i);//                options.inJustDecodeBounds = false;//                bitmap = BitmapFactory.decodeStream(in, null, options);//                break;//            }//            i += 1;//        }        return bitmap;    }    public static Bitmap getBitmapFromFile(File dst, int width, int height) {        if (null != dst && dst.exists()) {            BitmapFactory.Options opts = null;            if (width > 0 && height > 0) {                opts = new BitmapFactory.Options();                opts.inJustDecodeBounds = true;                BitmapFactory.decodeFile(dst.getPath(), opts);                // 计算图片缩放比例                final int minSideLength = Math.min(width, height);                opts.inSampleSize = computeSampleSize(opts, minSideLength,                        width * height);                opts.inJustDecodeBounds = false;                opts.inInputShareable = true;                opts.inPurgeable = true;            }            try {                return BitmapFactory.decodeFile(dst.getPath(), opts);            } catch (OutOfMemoryError e) {                e.printStackTrace();            }        }        return null;    }    public static int computeSampleSize(BitmapFactory.Options options,                                        int minSideLength, int maxNumOfPixels) {        int initialSize = computeInitialSampleSize(options, minSideLength,                maxNumOfPixels);        int roundedSize;        if (initialSize <= 8) {            roundedSize = 1;            while (roundedSize < initialSize) {                roundedSize <<= 1;            }        } else {            roundedSize = (initialSize + 7) / 8 * 8;        }        return roundedSize;    }    private static int computeInitialSampleSize(BitmapFactory.Options options,                                                int minSideLength, int maxNumOfPixels) {        double w = options.outWidth;        double h = options.outHeight;        int lowerBound = (maxNumOfPixels == -1) ? 1 : (int) Math.ceil(Math                .sqrt(w * h / maxNumOfPixels));        int upperBound = (minSideLength == -1) ? 128 : (int) Math.min(Math                .floor(w / minSideLength), Math.floor(h / minSideLength));        if (upperBound < lowerBound) {            // return the larger one when there is no overlapping zone.            return lowerBound;        }        if ((maxNumOfPixels == -1) && (minSideLength == -1)) {            return 1;        } else if (minSideLength == -1) {            return lowerBound;        } else {            return upperBound;        }    }}